---
layout: single
title: "数据库设计四大范式"
categories: Technology Database
date: 2014-12-28T07:33:06+00:00
---

最近在看某平台的数据表设计，发现问题很大，导致依赖这些表的代码逻辑也非常凌乱，想要进行梳理。就重新温习了一下数据库表设计的“范式”概念，在网上搜了一下，竟然发现有三大范式、五大范式、六大范式等，暂时有点摸不着北，先逐一熟悉一下。

为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。

每个范式用一句话就能概括：

- 1NF：原子性，即每个字段都不可以在分割了。
- 2NF：唯一性，即每个表只描述一个实体，这个实体要有主键，非主关键字要完全依赖主键，之所以说是完全依赖，是因为在组合主键存在的情况下，非主关键字不能只依赖部分关键字。
- 3NF：主键关联性，一个表中不能包含其他表中已经存在的非主键字段信息，也就是说只可以包含其他表的主键信息，这样就是主外键，通过主外键就可以进行表之间的连接(join)，3NF主要是减少数据冗余。
- BCNF：bc范式是在第三范式的基础上的一种特殊情况，既每个表中只有一个候选键。

下面举例来说明这些范式：

## 1st NF：原子性  ##

第一范式是最基本的范式。如果数据库表中的**所有字段值都是不可分解的原子值**，就说明该数据库表满足了第一范式。

第一范式的合理遵循需要根据系统的**实际需求**来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示：

|用户信息表|
| 编号 | 姓名 | 性别 | 年龄 | 联系电话 | 省份 | 城市 | 详细地址 |
|:---|:---|:---|:---|:---|:---|:---|:---|
|1|张红欣|男|26|0378-23459876|河南|开封|朝阳区新华路23号|
|----
|2|李四平|女|32|0751-65432584|广东|广州|白云区天明路19号|
|----
|3|刘志国|男|21|0371-87659852|河南|郑州|二七区大学路18号|
|----
|4|郭晓明|女|27|0371-62256789|河南|郑州|新郑市薛店街21号|
|----
{: rules="groups"}

上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。

## 2nd NF：唯一性  ##

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。**

比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示：

|订单信息表|
| 订单编号 | 商品编号 | 商品名称 | 数量 | 单位 | 价格 | 客户 | 所属单位 | 联系方式 |
|:---|:---|:---|:---|:---|:---|:---|:---|:---|
|001|1|挖掘机|1|台|120000|张三|上海久治|021-43389796|
|----
|002|2|冲击钻|8|把|230   |张三|上海久治|021-43389796|
|----
|003|3|铲车  |2|辆|98000 |李四|北京长安|010-67865433|
|----
{: rules="groups"}

这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。

而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示：

|订单信息表|
| 订单编号 | 客户 | 所属单位 | 联系方式 |
|:---|:---|:---|:---|
|001|张三|上海久治|021-43389796|
|----
|002|张三|上海久治|021-43389796|
|----
|003|李四|北京长安|010-67865433|
|----
{: rules="groups"}

|订单项目表|
| 订单编号 | 商品编号 | 数量 | 
|:---|:---|:---|:---|
|001|1|挖掘机|1|
|----
|002|2|冲击钻|8|
|----
|003|3|铲车  |2|
|----
{: rules="groups"}

|商品信息表|
| 商品名称 | 单位 | 价格 |
|:---|:---|:---|
|1|挖掘机|台|120000|
|----
|2|冲击钻|把|230   |
|----
|3|铲车  |辆|98000 |
|----
{: rules="groups"}

这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。

## 3nd NF：主键关联性  ##

第三范式需要确保数据表中的**包含外表的列只能是外表的主键**。

比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表：

|订单信息表|
| 订单编号 | 订单项目 | 负责人 | 业务员 | 订单数量 | 客户编号 |
|:---|:---|:---|:---|:---|:---|
|001|1|挖掘机|刘明|李东明|1台|1|
|----
|002|2|冲击钻|李刚|霍新丰|8个|2|
|----
|003|3|铲车  |李四|艾美丽|2辆|1|
|----
{: rules="groups"}

|客户信息表|
| 客户编号 | 客户名称| 所属单位 | 联系方式 |
|:---|:---|:---|:---|
|001|李聪|上海久治|021-43389796|
|----
|002|张庆|个体经营|010-88657786|
|----
{: rules="groups"}

这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。

注意，在一些特殊情况下，如为了减少多表连接操作、提高查询速度，会主动利用数据冗余来换取效率。这种情况通常出现于报表数据库中、数据仓库这类分析型数据库中。

## BCNF：Boyce-Codd ##

在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖，则符合Boyce-Codd范式。例如，假设仓库管理关系表为UserWarehouse（仓库ID，存储物品ID，管理员ID，数量），且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品，则这个数据库表中存在如下决定关系：

（仓库ID，存储物品ID）->（管理员ID，数量）

（管理员ID，存储物品ID）->（仓库ID，数量）

所以，（仓库ID，存储物品ID）和（管理员ID，存储物品ID）都是UserWarehouse的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：

（仓库ID）->（管理员ID）

（管理员ID）->（仓库ID）

即存在关键字段决定关键字段的情况，所以其不符合Boyce-Codd范式。为了符合Boyce-Codd范式，应当把仓库管理关系表分解为两个关系表：仓库管理表UserWarehouse（仓库ID，管理员ID）和仓库表Warehouse（仓库ID，存储物品ID，数量）。